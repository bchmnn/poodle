# coding: utf-8

"""
    Moodle Webservice API

    Auto-generated OpenAPI spec for Moodle's Webservice API.

    The version of the OpenAPI document: 4.5.6 (Build: 20250811)
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from poodle_async_full.models.core_block_get_course_blocks_response_blocks_inner_contents_files_inner import CoreBlockGetCourseBlocksResponseBlocksInnerContentsFilesInner
from typing import Optional, Set
from typing_extensions import Self

from poodle_async_full.configuration import settings

class ModGlossaryGetGlossariesByCoursesResponseGlossariesInner(BaseModel):
    """
    Glossaries
    """ # noqa: E501
    allowcomments: Optional[StrictInt] = Field(description="If enabled, all participants with permission to create comments will be able to add comments to glossary entries")
    allowduplicatedentries: Optional[StrictInt] = Field(description="If enabled, multiple entries can have the same concept name")
    allowprintview: Optional[StrictInt] = Field(description="If enabled, students are provided with a link to a printer-friendly version of the glossary. The link is always available to teachers")
    approvaldisplayformat: Optional[StrictStr] = Field(description="When approving glossary items you may wish to use a different display format")
    assessed: Optional[StrictInt] = Field(description="Aggregate type")
    assesstimefinish: Optional[StrictInt] = Field(description="Restrict rating to items created before this")
    assesstimestart: Optional[StrictInt] = Field(description="Restrict rating to items created after this")
    browsemodes: List[Optional[StrictStr]]
    canaddentry: Optional[StrictInt] = Field(default=None, description="Whether the user can add a new entry")
    completionentries: Optional[StrictInt] = Field(description="Number of entries to complete")
    course: Optional[StrictInt] = Field(description="Course id")
    coursemodule: Optional[StrictInt] = Field(description="Course module id")
    defaultapproval: Optional[StrictInt] = Field(description="If set to no, entries require approving by a teacher before they are viewable by everyone.")
    displayformat: Optional[StrictStr] = Field(description="Display format type")
    editalways: Optional[StrictInt] = Field(description="Always allow editing")
    entbypage: Optional[StrictInt] = Field(description="Entries shown per page")
    globalglossary: Optional[StrictInt]
    groupingid: Optional[StrictInt] = Field(default=None, description="Group id")
    groupmode: Optional[StrictInt] = Field(default=None, description="Group mode")
    id: Optional[StrictInt] = Field(description="Activity instance id")
    intro: Optional[StrictStr] = Field(description="Activity introduction")
    introfiles: Optional[List[CoreBlockGetCourseBlocksResponseBlocksInnerContentsFilesInner]] = Field(default=None, description="Files in the introduction")
    introformat: Optional[StrictInt] = Field(description="intro format (1 = HTML, 0 = MOODLE, 2 = PLAIN, or 4 = MARKDOWN)")
    lang: Optional[StrictStr] = Field(default=None, description="Forced activity language")
    mainglossary: Optional[StrictInt] = Field(description="If enabled this glossary is a main glossary.")
    name: Optional[StrictStr] = Field(description="Activity name")
    rssarticles: Optional[StrictInt] = Field(description="This setting specifies the number of glossary entry concepts to include in the RSS feed. Between 5 and 20 generally acceptable")
    rsstype: Optional[StrictInt] = Field(description="To enable the RSS feed for this activity, select either concepts with author or concepts without author to be included in the feed")
    scale: Optional[StrictInt] = Field(description="Scale ID")
    section: Optional[StrictInt] = Field(default=None, description="Course section id")
    showall: Optional[StrictInt] = Field(description="If enabled, participants can browse all entries at once")
    showalphabet: Optional[StrictInt] = Field(description="If enabled, participants can browse the glossary by letters of the alphabet")
    showspecial: Optional[StrictInt] = Field(description="If enabled, participants can browse the glossary by special characters, such as @ and #")
    timecreated: Optional[StrictInt] = Field(description="Time created")
    timemodified: Optional[StrictInt] = Field(description="Time modified")
    usedynalink: Optional[StrictInt] = Field(description="If site-wide glossary auto-linking has been enabled by an administrator and this checkbox is ticked, the entry will be automatically linked wherever the concept words and phrases appear throughout the rest of the course.")
    visible: Optional[StrictBool] = Field(default=None, description="Visible")
    __properties: ClassVar[List[str]] = ["allowcomments", "allowduplicatedentries", "allowprintview", "approvaldisplayformat", "assessed", "assesstimefinish", "assesstimestart", "browsemodes", "canaddentry", "completionentries", "course", "coursemodule", "defaultapproval", "displayformat", "editalways", "entbypage", "globalglossary", "groupingid", "groupmode", "id", "intro", "introfiles", "introformat", "lang", "mainglossary", "name", "rssarticles", "rsstype", "scale", "section", "showall", "showalphabet", "showspecial", "timecreated", "timemodified", "usedynalink", "visible"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ModGlossaryGetGlossariesByCoursesResponseGlossariesInner from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in introfiles (list)
        _items = []
        if self.introfiles:
            for _item_introfiles in self.introfiles:
                if _item_introfiles:
                    _items.append(_item_introfiles.to_dict())
            _dict['introfiles'] = _items
        # set to None if allowcomments (nullable) is None
        # and model_fields_set contains the field
        if self.allowcomments is None and "allowcomments" in self.model_fields_set:
            _dict['allowcomments'] = None

        # set to None if allowduplicatedentries (nullable) is None
        # and model_fields_set contains the field
        if self.allowduplicatedentries is None and "allowduplicatedentries" in self.model_fields_set:
            _dict['allowduplicatedentries'] = None

        # set to None if allowprintview (nullable) is None
        # and model_fields_set contains the field
        if self.allowprintview is None and "allowprintview" in self.model_fields_set:
            _dict['allowprintview'] = None

        # set to None if approvaldisplayformat (nullable) is None
        # and model_fields_set contains the field
        if self.approvaldisplayformat is None and "approvaldisplayformat" in self.model_fields_set:
            _dict['approvaldisplayformat'] = None

        # set to None if assessed (nullable) is None
        # and model_fields_set contains the field
        if self.assessed is None and "assessed" in self.model_fields_set:
            _dict['assessed'] = None

        # set to None if assesstimefinish (nullable) is None
        # and model_fields_set contains the field
        if self.assesstimefinish is None and "assesstimefinish" in self.model_fields_set:
            _dict['assesstimefinish'] = None

        # set to None if assesstimestart (nullable) is None
        # and model_fields_set contains the field
        if self.assesstimestart is None and "assesstimestart" in self.model_fields_set:
            _dict['assesstimestart'] = None

        # set to None if canaddentry (nullable) is None
        # and model_fields_set contains the field
        if self.canaddentry is None and "canaddentry" in self.model_fields_set:
            _dict['canaddentry'] = None

        # set to None if completionentries (nullable) is None
        # and model_fields_set contains the field
        if self.completionentries is None and "completionentries" in self.model_fields_set:
            _dict['completionentries'] = None

        # set to None if course (nullable) is None
        # and model_fields_set contains the field
        if self.course is None and "course" in self.model_fields_set:
            _dict['course'] = None

        # set to None if coursemodule (nullable) is None
        # and model_fields_set contains the field
        if self.coursemodule is None and "coursemodule" in self.model_fields_set:
            _dict['coursemodule'] = None

        # set to None if defaultapproval (nullable) is None
        # and model_fields_set contains the field
        if self.defaultapproval is None and "defaultapproval" in self.model_fields_set:
            _dict['defaultapproval'] = None

        # set to None if displayformat (nullable) is None
        # and model_fields_set contains the field
        if self.displayformat is None and "displayformat" in self.model_fields_set:
            _dict['displayformat'] = None

        # set to None if editalways (nullable) is None
        # and model_fields_set contains the field
        if self.editalways is None and "editalways" in self.model_fields_set:
            _dict['editalways'] = None

        # set to None if entbypage (nullable) is None
        # and model_fields_set contains the field
        if self.entbypage is None and "entbypage" in self.model_fields_set:
            _dict['entbypage'] = None

        # set to None if globalglossary (nullable) is None
        # and model_fields_set contains the field
        if self.globalglossary is None and "globalglossary" in self.model_fields_set:
            _dict['globalglossary'] = None

        # set to None if groupingid (nullable) is None
        # and model_fields_set contains the field
        if self.groupingid is None and "groupingid" in self.model_fields_set:
            _dict['groupingid'] = None

        # set to None if groupmode (nullable) is None
        # and model_fields_set contains the field
        if self.groupmode is None and "groupmode" in self.model_fields_set:
            _dict['groupmode'] = None

        # set to None if id (nullable) is None
        # and model_fields_set contains the field
        if self.id is None and "id" in self.model_fields_set:
            _dict['id'] = None

        # set to None if intro (nullable) is None
        # and model_fields_set contains the field
        if self.intro is None and "intro" in self.model_fields_set:
            _dict['intro'] = None

        # set to None if introformat (nullable) is None
        # and model_fields_set contains the field
        if self.introformat is None and "introformat" in self.model_fields_set:
            _dict['introformat'] = None

        # set to None if lang (nullable) is None
        # and model_fields_set contains the field
        if self.lang is None and "lang" in self.model_fields_set:
            _dict['lang'] = None

        # set to None if mainglossary (nullable) is None
        # and model_fields_set contains the field
        if self.mainglossary is None and "mainglossary" in self.model_fields_set:
            _dict['mainglossary'] = None

        # set to None if name (nullable) is None
        # and model_fields_set contains the field
        if self.name is None and "name" in self.model_fields_set:
            _dict['name'] = None

        # set to None if rssarticles (nullable) is None
        # and model_fields_set contains the field
        if self.rssarticles is None and "rssarticles" in self.model_fields_set:
            _dict['rssarticles'] = None

        # set to None if rsstype (nullable) is None
        # and model_fields_set contains the field
        if self.rsstype is None and "rsstype" in self.model_fields_set:
            _dict['rsstype'] = None

        # set to None if scale (nullable) is None
        # and model_fields_set contains the field
        if self.scale is None and "scale" in self.model_fields_set:
            _dict['scale'] = None

        # set to None if section (nullable) is None
        # and model_fields_set contains the field
        if self.section is None and "section" in self.model_fields_set:
            _dict['section'] = None

        # set to None if showall (nullable) is None
        # and model_fields_set contains the field
        if self.showall is None and "showall" in self.model_fields_set:
            _dict['showall'] = None

        # set to None if showalphabet (nullable) is None
        # and model_fields_set contains the field
        if self.showalphabet is None and "showalphabet" in self.model_fields_set:
            _dict['showalphabet'] = None

        # set to None if showspecial (nullable) is None
        # and model_fields_set contains the field
        if self.showspecial is None and "showspecial" in self.model_fields_set:
            _dict['showspecial'] = None

        # set to None if timecreated (nullable) is None
        # and model_fields_set contains the field
        if self.timecreated is None and "timecreated" in self.model_fields_set:
            _dict['timecreated'] = None

        # set to None if timemodified (nullable) is None
        # and model_fields_set contains the field
        if self.timemodified is None and "timemodified" in self.model_fields_set:
            _dict['timemodified'] = None

        # set to None if usedynalink (nullable) is None
        # and model_fields_set contains the field
        if self.usedynalink is None and "usedynalink" in self.model_fields_set:
            _dict['usedynalink'] = None

        # set to None if visible (nullable) is None
        # and model_fields_set contains the field
        if self.visible is None and "visible" in self.model_fields_set:
            _dict['visible'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ModGlossaryGetGlossariesByCoursesResponseGlossariesInner from a dict"""
        if obj is None:
            return None

        relaxed = settings.relaxe_all_models or "ModGlossaryGetGlossariesByCoursesResponseGlossariesInner" in settings.relaxed_models

        if not isinstance(obj, dict):
            return cls.model_construct(**obj) if relaxed else cls.model_validate(obj)

        data = {
            "allowcomments": obj.get("allowcomments"),
            "allowduplicatedentries": obj.get("allowduplicatedentries"),
            "allowprintview": obj.get("allowprintview"),
            "approvaldisplayformat": obj.get("approvaldisplayformat"),
            "assessed": obj.get("assessed"),
            "assesstimefinish": obj.get("assesstimefinish"),
            "assesstimestart": obj.get("assesstimestart"),
            "browsemodes": obj.get("browsemodes"),
            "canaddentry": obj.get("canaddentry"),
            "completionentries": obj.get("completionentries"),
            "course": obj.get("course"),
            "coursemodule": obj.get("coursemodule"),
            "defaultapproval": obj.get("defaultapproval"),
            "displayformat": obj.get("displayformat"),
            "editalways": obj.get("editalways"),
            "entbypage": obj.get("entbypage"),
            "globalglossary": obj.get("globalglossary"),
            "groupingid": obj.get("groupingid"),
            "groupmode": obj.get("groupmode"),
            "id": obj.get("id"),
            "intro": obj.get("intro"),
            "introfiles": [CoreBlockGetCourseBlocksResponseBlocksInnerContentsFilesInner.from_dict(_item) for _item in obj["introfiles"]] if obj.get("introfiles") is not None else None,
            "introformat": obj.get("introformat"),
            "lang": obj.get("lang"),
            "mainglossary": obj.get("mainglossary"),
            "name": obj.get("name"),
            "rssarticles": obj.get("rssarticles"),
            "rsstype": obj.get("rsstype"),
            "scale": obj.get("scale"),
            "section": obj.get("section"),
            "showall": obj.get("showall"),
            "showalphabet": obj.get("showalphabet"),
            "showspecial": obj.get("showspecial"),
            "timecreated": obj.get("timecreated"),
            "timemodified": obj.get("timemodified"),
            "usedynalink": obj.get("usedynalink"),
            "visible": obj.get("visible")
        }
        _obj = cls.model_construct(**data) if relaxed else cls.model_validate(data)
        return _obj


