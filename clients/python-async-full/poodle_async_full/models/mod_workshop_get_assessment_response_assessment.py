# coding: utf-8

"""
    Moodle Webservice API

    Auto-generated OpenAPI spec for Moodle's Webservice API.

    The version of the OpenAPI document: 4.5.6 (Build: 20250811)
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from poodle_async_full.models.core_blog_get_entries_response_entries_inner_attachmentfiles_inner import CoreBlogGetEntriesResponseEntriesInnerAttachmentfilesInner
from typing import Optional, Set
from typing_extensions import Self

from poodle_async_full.configuration import settings

class ModWorkshopGetAssessmentResponseAssessment(BaseModel):
    """
    ModWorkshopGetAssessmentResponseAssessment
    """ # noqa: E501
    feedbackattachmentfiles: List[CoreBlogGetEntriesResponseEntriesInnerAttachmentfilesInner] = Field(description="feedbackattachmentfiles")
    feedbackauthor: Optional[StrictStr] = Field(description="The comment/feedback from the reviewer for the author.")
    feedbackauthorattachment: Optional[StrictInt] = Field(description="Are there some files attached to the feedbackauthor field?                     Sets to 1 by file_postupdate_standard_filemanager().")
    feedbackauthorformat: Optional[StrictInt] = Field(default=0, description="feedbackauthor format (1 = HTML, 0 = MOODLE, 2 = PLAIN, or 4 = MARKDOWN)")
    feedbackcontentfiles: List[CoreBlogGetEntriesResponseEntriesInnerAttachmentfilesInner] = Field(description="feedbackcontentfiles")
    feedbackreviewer: Optional[StrictStr] = Field(default=None, description="The comment/feedback from the teacher for the reviewer.                     For example the reason why the grade for assessment was overridden")
    feedbackreviewerformat: Optional[StrictInt] = Field(default=0, description="feedbackreviewer format (1 = HTML, 0 = MOODLE, 2 = PLAIN, or 4 = MARKDOWN)")
    grade: Optional[Union[StrictFloat, StrictInt]] = Field(description="The aggregated grade for submission suggested by the reviewer.                     The grade 0..100 is computed from the values assigned to the assessment dimensions fields. If NULL then it has not been aggregated yet.")
    gradinggrade: Optional[Union[StrictFloat, StrictInt]] = Field(description="The computed grade 0..100 for this assessment. If NULL then it has not been computed yet.")
    gradinggradeover: Optional[Union[StrictFloat, StrictInt]] = Field(description="Grade for the assessment manually overridden by a teacher.                     Grade is always from interval 0..100. If NULL then the grade is not overriden.")
    gradinggradeoverby: Optional[StrictInt] = Field(description="The id of the user who has overridden the grade for submission.")
    id: StrictInt = Field(description="The primary key of the record.")
    reviewerid: StrictInt = Field(description="The id of the reviewer who makes this assessment")
    submissionid: StrictInt = Field(description="The id of the assessed submission")
    timecreated: Optional[StrictInt] = Field(description="If 0 then the assessment was allocated but the reviewer has not assessed yet.                     If greater than 0 then the timestamp of when the reviewer assessed for the first time")
    timemodified: Optional[StrictInt] = Field(description="If 0 then the assessment was allocated but the reviewer has not assessed yet.                     If greater than 0 then the timestamp of when the reviewer assessed for the last time")
    weight: StrictInt = Field(description="The weight of the assessment for the purposes of aggregation")
    __properties: ClassVar[List[str]] = ["feedbackattachmentfiles", "feedbackauthor", "feedbackauthorattachment", "feedbackauthorformat", "feedbackcontentfiles", "feedbackreviewer", "feedbackreviewerformat", "grade", "gradinggrade", "gradinggradeover", "gradinggradeoverby", "id", "reviewerid", "submissionid", "timecreated", "timemodified", "weight"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ModWorkshopGetAssessmentResponseAssessment from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in feedbackattachmentfiles (list)
        _items = []
        if self.feedbackattachmentfiles:
            for _item_feedbackattachmentfiles in self.feedbackattachmentfiles:
                if _item_feedbackattachmentfiles:
                    _items.append(_item_feedbackattachmentfiles.to_dict())
            _dict['feedbackattachmentfiles'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in feedbackcontentfiles (list)
        _items = []
        if self.feedbackcontentfiles:
            for _item_feedbackcontentfiles in self.feedbackcontentfiles:
                if _item_feedbackcontentfiles:
                    _items.append(_item_feedbackcontentfiles.to_dict())
            _dict['feedbackcontentfiles'] = _items
        # set to None if feedbackauthor (nullable) is None
        # and model_fields_set contains the field
        if self.feedbackauthor is None and "feedbackauthor" in self.model_fields_set:
            _dict['feedbackauthor'] = None

        # set to None if feedbackauthorattachment (nullable) is None
        # and model_fields_set contains the field
        if self.feedbackauthorattachment is None and "feedbackauthorattachment" in self.model_fields_set:
            _dict['feedbackauthorattachment'] = None

        # set to None if feedbackauthorformat (nullable) is None
        # and model_fields_set contains the field
        if self.feedbackauthorformat is None and "feedbackauthorformat" in self.model_fields_set:
            _dict['feedbackauthorformat'] = None

        # set to None if feedbackreviewer (nullable) is None
        # and model_fields_set contains the field
        if self.feedbackreviewer is None and "feedbackreviewer" in self.model_fields_set:
            _dict['feedbackreviewer'] = None

        # set to None if feedbackreviewerformat (nullable) is None
        # and model_fields_set contains the field
        if self.feedbackreviewerformat is None and "feedbackreviewerformat" in self.model_fields_set:
            _dict['feedbackreviewerformat'] = None

        # set to None if grade (nullable) is None
        # and model_fields_set contains the field
        if self.grade is None and "grade" in self.model_fields_set:
            _dict['grade'] = None

        # set to None if gradinggrade (nullable) is None
        # and model_fields_set contains the field
        if self.gradinggrade is None and "gradinggrade" in self.model_fields_set:
            _dict['gradinggrade'] = None

        # set to None if gradinggradeover (nullable) is None
        # and model_fields_set contains the field
        if self.gradinggradeover is None and "gradinggradeover" in self.model_fields_set:
            _dict['gradinggradeover'] = None

        # set to None if gradinggradeoverby (nullable) is None
        # and model_fields_set contains the field
        if self.gradinggradeoverby is None and "gradinggradeoverby" in self.model_fields_set:
            _dict['gradinggradeoverby'] = None

        # set to None if timecreated (nullable) is None
        # and model_fields_set contains the field
        if self.timecreated is None and "timecreated" in self.model_fields_set:
            _dict['timecreated'] = None

        # set to None if timemodified (nullable) is None
        # and model_fields_set contains the field
        if self.timemodified is None and "timemodified" in self.model_fields_set:
            _dict['timemodified'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ModWorkshopGetAssessmentResponseAssessment from a dict"""
        if obj is None:
            return None

        relaxed = settings.relaxe_all_models or "ModWorkshopGetAssessmentResponseAssessment" in settings.relaxed_models

        if not isinstance(obj, dict):
            return cls.model_construct(**obj) if relaxed else cls.model_validate(obj)

        data = {
            "feedbackattachmentfiles": [CoreBlogGetEntriesResponseEntriesInnerAttachmentfilesInner.from_dict(_item) for _item in obj["feedbackattachmentfiles"]] if obj.get("feedbackattachmentfiles") is not None else None,
            "feedbackauthor": obj.get("feedbackauthor"),
            "feedbackauthorattachment": obj.get("feedbackauthorattachment") if obj.get("feedbackauthorattachment") is not None else 0,
            "feedbackauthorformat": obj.get("feedbackauthorformat") if obj.get("feedbackauthorformat") is not None else 0,
            "feedbackcontentfiles": [CoreBlogGetEntriesResponseEntriesInnerAttachmentfilesInner.from_dict(_item) for _item in obj["feedbackcontentfiles"]] if obj.get("feedbackcontentfiles") is not None else None,
            "feedbackreviewer": obj.get("feedbackreviewer"),
            "feedbackreviewerformat": obj.get("feedbackreviewerformat") if obj.get("feedbackreviewerformat") is not None else 0,
            "grade": obj.get("grade"),
            "gradinggrade": obj.get("gradinggrade"),
            "gradinggradeover": obj.get("gradinggradeover"),
            "gradinggradeoverby": obj.get("gradinggradeoverby"),
            "id": obj.get("id") if obj.get("id") is not None else 0,
            "reviewerid": obj.get("reviewerid") if obj.get("reviewerid") is not None else 0,
            "submissionid": obj.get("submissionid") if obj.get("submissionid") is not None else 0,
            "timecreated": obj.get("timecreated") if obj.get("timecreated") is not None else 0,
            "timemodified": obj.get("timemodified") if obj.get("timemodified") is not None else 0,
            "weight": obj.get("weight") if obj.get("weight") is not None else 0
        }
        _obj = cls.model_construct(**data) if relaxed else cls.model_validate(data)
        return _obj


