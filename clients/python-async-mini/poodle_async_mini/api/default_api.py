# coding: utf-8

"""
    Moodle Webservice API

    Auto-generated OpenAPI spec for Moodle's Webservice API.

    The version of the OpenAPI document: 4.5.6 (Build: 20250811)
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
import json
import re
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr
from typing import List, Optional
from typing_extensions import Annotated
from poodle_async_mini.models.core_course_get_contents_parameters_options_inner import CoreCourseGetContentsParametersOptionsInner
from poodle_async_mini.models.core_course_get_contents_response_inner import CoreCourseGetContentsResponseInner
from poodle_async_mini.models.core_enrol_get_users_courses_response_inner import CoreEnrolGetUsersCoursesResponseInner
from poodle_async_mini.models.core_group_get_course_groups_response_inner import CoreGroupGetCourseGroupsResponseInner
from poodle_async_mini.models.core_webservice_get_site_info_response import CoreWebserviceGetSiteInfoResponse
from poodle_async_mini.models.gradereport_user_get_grade_items_response import GradereportUserGetGradeItemsResponse
from poodle_async_mini.models.login_token200_response import LoginToken200Response
from poodle_async_mini.models.mod_assign_get_assignments_response import ModAssignGetAssignmentsResponse
from poodle_async_mini.models.mod_assign_get_submissions_response import ModAssignGetSubmissionsResponse
from poodle_async_mini.models.mod_assign_list_participants_response_inner import ModAssignListParticipantsResponseInner

from poodle_async_mini.api_client import ApiClient, RequestSerialized
from poodle_async_mini.api_response import ApiResponse
from poodle_async_mini.rest import RESTResponseType
from poodle_async_mini.exceptions import ApiException


def fix_file_url(url: str, token: str) -> str:
    return re.sub(
        r"(\/webservice)?\/pluginfile\.php", f"/tokenpluginfile.php/{token}", url
    )

def is_primitive(value: Any):
    return isinstance(value, (int, str, bool))


def is_collection(value: Any):
    return isinstance(value, (set, list))


def _parse_form(data: Any, prefix: str = "") -> List[Tuple[str, str]]:
    if data is None:
        return []
    if is_primitive(data):
        value = str(data).lower() if isinstance(data, bool) else str(data)
        return [(prefix, value)]
    result: List[Tuple[str, str]] = []
    if is_collection(data):
        for i, value in enumerate(data):
            result = result + _parse_form(
                value, prefix + (f"{i}" if prefix == "" else f"[{i}]")
            )
    else:
        dictionary = data.__dict__ if hasattr(data, "__dict__") else data
        for key in dictionary.keys():
            value = dictionary[key]
            result = result + _parse_form(
                value, prefix + (f"{key}" if prefix == "" else f"[{key}]")
            )
    return result


def parse_form(data: Dict[str, Any]):
    return _parse_form(data)


class DefaultApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    async def get_file(self, url, userprivateaccesskey: Optional[str]=None):
        if userprivateaccesskey is None and hasattr(self, "core_webservice_get_site_info"):
            userprivateaccesskey = (await self.core_webservice_get_site_info()).userprivateaccesskey
        if userprivateaccesskey is None:
            raise ApiException("Current site is missing userprivateaccesskey")
        return await self.api_client.call_api(
            method="GET", url=fix_file_url(url, userprivateaccesskey)
        )


    @validate_call
    async def core_course_get_contents(
        self,
        courseid: Annotated[Optional[StrictInt], Field(description="course id")],
        options: Annotated[Optional[List[CoreCourseGetContentsParametersOptionsInner]], Field(description="Options, used since Moodle 2.9")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[CoreCourseGetContentsResponseInner]:
        """Get course contents

        Get course contents

        :param courseid: course id (required)
        :type courseid: int
        :param options: Options, used since Moodle 2.9
        :type options: List[CoreCourseGetContentsParametersOptionsInner]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._core_course_get_contents_serialize(
            courseid=courseid,
            options=options,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[CoreCourseGetContentsResponseInner]",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def core_course_get_contents_with_http_info(
        self,
        courseid: Annotated[Optional[StrictInt], Field(description="course id")],
        options: Annotated[Optional[List[CoreCourseGetContentsParametersOptionsInner]], Field(description="Options, used since Moodle 2.9")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[CoreCourseGetContentsResponseInner]]:
        """Get course contents

        Get course contents

        :param courseid: course id (required)
        :type courseid: int
        :param options: Options, used since Moodle 2.9
        :type options: List[CoreCourseGetContentsParametersOptionsInner]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._core_course_get_contents_serialize(
            courseid=courseid,
            options=options,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[CoreCourseGetContentsResponseInner]",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def core_course_get_contents_without_preload_content(
        self,
        courseid: Annotated[Optional[StrictInt], Field(description="course id")],
        options: Annotated[Optional[List[CoreCourseGetContentsParametersOptionsInner]], Field(description="Options, used since Moodle 2.9")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get course contents

        Get course contents

        :param courseid: course id (required)
        :type courseid: int
        :param options: Options, used since Moodle 2.9
        :type options: List[CoreCourseGetContentsParametersOptionsInner]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._core_course_get_contents_serialize(
            courseid=courseid,
            options=options,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[CoreCourseGetContentsResponseInner]",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _core_course_get_contents_serialize(
        self,
        courseid,
        options,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'options': 'csv',
        }

        _resource_path = '/webservice/rest/server.php#core_course_get_contents'.split('#')[0]

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if '/webservice/rest/server.php' in _resource_path:
            _query_params.append(('moodlewsrestformat', 'json'))
            _query_params.append(('wsfunction', 'core_course_get_contents'))
        if '/lib/ajax/service-nologin.php' in _resource_path:
            _args_param = None
            for _param in _query_params:
                if _param[0] == 'args':
                    _args_param = _param
            if _args_param is not None:
                _query_params.remove(_args_param)
            else:
                _args_param = ('args', {})
            _new_args = ('args', json.dumps([{
                'index': 0,
                'methodname': 'core_course_get_contents',
                'args': _args_param[1]
            }]))
            _query_params.append(_new_args)
        # process the header parameters
        # process the form parameters
        if courseid is not None:
            _form_params += parse_form({'courseid': courseid})
        if options is not None:
            _form_params += parse_form({'options': options})
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'wstoken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path=_resource_path,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def core_enrol_get_users_courses(
        self,
        userid: Annotated[Optional[StrictInt], Field(description="user id")],
        returnusercount: Annotated[Optional[StrictBool], Field(description="Include count of enrolled users for each course? This can add several seconds to the response time if a user is on several large courses, so set this to false if the value will not be used to improve performance.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[CoreEnrolGetUsersCoursesResponseInner]:
        """Get the list of courses where a user is enrolled in

        Get the list of courses where a user is enrolled in

        :param userid: user id (required)
        :type userid: int
        :param returnusercount: Include count of enrolled users for each course? This can add several seconds to the response time if a user is on several large courses, so set this to false if the value will not be used to improve performance.
        :type returnusercount: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._core_enrol_get_users_courses_serialize(
            userid=userid,
            returnusercount=returnusercount,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[CoreEnrolGetUsersCoursesResponseInner]",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def core_enrol_get_users_courses_with_http_info(
        self,
        userid: Annotated[Optional[StrictInt], Field(description="user id")],
        returnusercount: Annotated[Optional[StrictBool], Field(description="Include count of enrolled users for each course? This can add several seconds to the response time if a user is on several large courses, so set this to false if the value will not be used to improve performance.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[CoreEnrolGetUsersCoursesResponseInner]]:
        """Get the list of courses where a user is enrolled in

        Get the list of courses where a user is enrolled in

        :param userid: user id (required)
        :type userid: int
        :param returnusercount: Include count of enrolled users for each course? This can add several seconds to the response time if a user is on several large courses, so set this to false if the value will not be used to improve performance.
        :type returnusercount: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._core_enrol_get_users_courses_serialize(
            userid=userid,
            returnusercount=returnusercount,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[CoreEnrolGetUsersCoursesResponseInner]",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def core_enrol_get_users_courses_without_preload_content(
        self,
        userid: Annotated[Optional[StrictInt], Field(description="user id")],
        returnusercount: Annotated[Optional[StrictBool], Field(description="Include count of enrolled users for each course? This can add several seconds to the response time if a user is on several large courses, so set this to false if the value will not be used to improve performance.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get the list of courses where a user is enrolled in

        Get the list of courses where a user is enrolled in

        :param userid: user id (required)
        :type userid: int
        :param returnusercount: Include count of enrolled users for each course? This can add several seconds to the response time if a user is on several large courses, so set this to false if the value will not be used to improve performance.
        :type returnusercount: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._core_enrol_get_users_courses_serialize(
            userid=userid,
            returnusercount=returnusercount,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[CoreEnrolGetUsersCoursesResponseInner]",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _core_enrol_get_users_courses_serialize(
        self,
        userid,
        returnusercount,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _resource_path = '/webservice/rest/server.php#core_enrol_get_users_courses'.split('#')[0]

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if '/webservice/rest/server.php' in _resource_path:
            _query_params.append(('moodlewsrestformat', 'json'))
            _query_params.append(('wsfunction', 'core_enrol_get_users_courses'))
        if '/lib/ajax/service-nologin.php' in _resource_path:
            _args_param = None
            for _param in _query_params:
                if _param[0] == 'args':
                    _args_param = _param
            if _args_param is not None:
                _query_params.remove(_args_param)
            else:
                _args_param = ('args', {})
            _new_args = ('args', json.dumps([{
                'index': 0,
                'methodname': 'core_enrol_get_users_courses',
                'args': _args_param[1]
            }]))
            _query_params.append(_new_args)
        # process the header parameters
        # process the form parameters
        if returnusercount is not None:
            _form_params += parse_form({'returnusercount': returnusercount})
        if userid is not None:
            _form_params += parse_form({'userid': userid})
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'wstoken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path=_resource_path,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def core_group_get_course_groups(
        self,
        courseid: Annotated[Optional[StrictInt], Field(description="id of course")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[CoreGroupGetCourseGroupsResponseInner]:
        """Returns all groups in specified course.

        Returns all groups in specified course.

        :param courseid: id of course (required)
        :type courseid: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._core_group_get_course_groups_serialize(
            courseid=courseid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[CoreGroupGetCourseGroupsResponseInner]",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def core_group_get_course_groups_with_http_info(
        self,
        courseid: Annotated[Optional[StrictInt], Field(description="id of course")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[CoreGroupGetCourseGroupsResponseInner]]:
        """Returns all groups in specified course.

        Returns all groups in specified course.

        :param courseid: id of course (required)
        :type courseid: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._core_group_get_course_groups_serialize(
            courseid=courseid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[CoreGroupGetCourseGroupsResponseInner]",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def core_group_get_course_groups_without_preload_content(
        self,
        courseid: Annotated[Optional[StrictInt], Field(description="id of course")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Returns all groups in specified course.

        Returns all groups in specified course.

        :param courseid: id of course (required)
        :type courseid: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._core_group_get_course_groups_serialize(
            courseid=courseid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[CoreGroupGetCourseGroupsResponseInner]",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _core_group_get_course_groups_serialize(
        self,
        courseid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _resource_path = '/webservice/rest/server.php#core_group_get_course_groups'.split('#')[0]

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if '/webservice/rest/server.php' in _resource_path:
            _query_params.append(('moodlewsrestformat', 'json'))
            _query_params.append(('wsfunction', 'core_group_get_course_groups'))
        if '/lib/ajax/service-nologin.php' in _resource_path:
            _args_param = None
            for _param in _query_params:
                if _param[0] == 'args':
                    _args_param = _param
            if _args_param is not None:
                _query_params.remove(_args_param)
            else:
                _args_param = ('args', {})
            _new_args = ('args', json.dumps([{
                'index': 0,
                'methodname': 'core_group_get_course_groups',
                'args': _args_param[1]
            }]))
            _query_params.append(_new_args)
        # process the header parameters
        # process the form parameters
        if courseid is not None:
            _form_params += parse_form({'courseid': courseid})
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'wstoken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path=_resource_path,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def core_webservice_get_site_info(
        self,
        serviceshortnames: Annotated[Optional[List[Optional[StrictStr]]], Field(description="DEPRECATED PARAMETER - it was a design error in the original implementation. \\\\                     It is ignored now. (parameter kept for backward compatibility)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CoreWebserviceGetSiteInfoResponse:
        """Return some site info / user info / list web service functions

        Return some site info / user info / list web service functions

        :param serviceshortnames: DEPRECATED PARAMETER - it was a design error in the original implementation. \\\\                     It is ignored now. (parameter kept for backward compatibility)
        :type serviceshortnames: List[Optional[str]]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._core_webservice_get_site_info_serialize(
            serviceshortnames=serviceshortnames,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CoreWebserviceGetSiteInfoResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def core_webservice_get_site_info_with_http_info(
        self,
        serviceshortnames: Annotated[Optional[List[Optional[StrictStr]]], Field(description="DEPRECATED PARAMETER - it was a design error in the original implementation. \\\\                     It is ignored now. (parameter kept for backward compatibility)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CoreWebserviceGetSiteInfoResponse]:
        """Return some site info / user info / list web service functions

        Return some site info / user info / list web service functions

        :param serviceshortnames: DEPRECATED PARAMETER - it was a design error in the original implementation. \\\\                     It is ignored now. (parameter kept for backward compatibility)
        :type serviceshortnames: List[Optional[str]]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._core_webservice_get_site_info_serialize(
            serviceshortnames=serviceshortnames,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CoreWebserviceGetSiteInfoResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def core_webservice_get_site_info_without_preload_content(
        self,
        serviceshortnames: Annotated[Optional[List[Optional[StrictStr]]], Field(description="DEPRECATED PARAMETER - it was a design error in the original implementation. \\\\                     It is ignored now. (parameter kept for backward compatibility)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Return some site info / user info / list web service functions

        Return some site info / user info / list web service functions

        :param serviceshortnames: DEPRECATED PARAMETER - it was a design error in the original implementation. \\\\                     It is ignored now. (parameter kept for backward compatibility)
        :type serviceshortnames: List[Optional[str]]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._core_webservice_get_site_info_serialize(
            serviceshortnames=serviceshortnames,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CoreWebserviceGetSiteInfoResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _core_webservice_get_site_info_serialize(
        self,
        serviceshortnames,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'serviceshortnames': 'csv',
        }

        _resource_path = '/webservice/rest/server.php#core_webservice_get_site_info'.split('#')[0]

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if '/webservice/rest/server.php' in _resource_path:
            _query_params.append(('moodlewsrestformat', 'json'))
            _query_params.append(('wsfunction', 'core_webservice_get_site_info'))
        if '/lib/ajax/service-nologin.php' in _resource_path:
            _args_param = None
            for _param in _query_params:
                if _param[0] == 'args':
                    _args_param = _param
            if _args_param is not None:
                _query_params.remove(_args_param)
            else:
                _args_param = ('args', {})
            _new_args = ('args', json.dumps([{
                'index': 0,
                'methodname': 'core_webservice_get_site_info',
                'args': _args_param[1]
            }]))
            _query_params.append(_new_args)
        # process the header parameters
        # process the form parameters
        if serviceshortnames is not None:
            _form_params += parse_form({'serviceshortnames': serviceshortnames})
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'wstoken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path=_resource_path,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def gradereport_user_get_grade_items(
        self,
        courseid: Annotated[Optional[StrictInt], Field(description="Course Id")],
        groupid: Annotated[Optional[StrictInt], Field(description="Get users from this group only")] = None,
        userid: Annotated[Optional[StrictInt], Field(description="Return grades only for this user (optional)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GradereportUserGetGradeItemsResponse:
        """Returns the complete list of grade items for users in a course

        Returns the complete list of grade items for users in a course

        :param courseid: Course Id (required)
        :type courseid: int
        :param groupid: Get users from this group only
        :type groupid: int
        :param userid: Return grades only for this user (optional)
        :type userid: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._gradereport_user_get_grade_items_serialize(
            courseid=courseid,
            groupid=groupid,
            userid=userid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GradereportUserGetGradeItemsResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def gradereport_user_get_grade_items_with_http_info(
        self,
        courseid: Annotated[Optional[StrictInt], Field(description="Course Id")],
        groupid: Annotated[Optional[StrictInt], Field(description="Get users from this group only")] = None,
        userid: Annotated[Optional[StrictInt], Field(description="Return grades only for this user (optional)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GradereportUserGetGradeItemsResponse]:
        """Returns the complete list of grade items for users in a course

        Returns the complete list of grade items for users in a course

        :param courseid: Course Id (required)
        :type courseid: int
        :param groupid: Get users from this group only
        :type groupid: int
        :param userid: Return grades only for this user (optional)
        :type userid: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._gradereport_user_get_grade_items_serialize(
            courseid=courseid,
            groupid=groupid,
            userid=userid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GradereportUserGetGradeItemsResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def gradereport_user_get_grade_items_without_preload_content(
        self,
        courseid: Annotated[Optional[StrictInt], Field(description="Course Id")],
        groupid: Annotated[Optional[StrictInt], Field(description="Get users from this group only")] = None,
        userid: Annotated[Optional[StrictInt], Field(description="Return grades only for this user (optional)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Returns the complete list of grade items for users in a course

        Returns the complete list of grade items for users in a course

        :param courseid: Course Id (required)
        :type courseid: int
        :param groupid: Get users from this group only
        :type groupid: int
        :param userid: Return grades only for this user (optional)
        :type userid: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._gradereport_user_get_grade_items_serialize(
            courseid=courseid,
            groupid=groupid,
            userid=userid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GradereportUserGetGradeItemsResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _gradereport_user_get_grade_items_serialize(
        self,
        courseid,
        groupid,
        userid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _resource_path = '/webservice/rest/server.php#gradereport_user_get_grade_items'.split('#')[0]

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if '/webservice/rest/server.php' in _resource_path:
            _query_params.append(('moodlewsrestformat', 'json'))
            _query_params.append(('wsfunction', 'gradereport_user_get_grade_items'))
        if '/lib/ajax/service-nologin.php' in _resource_path:
            _args_param = None
            for _param in _query_params:
                if _param[0] == 'args':
                    _args_param = _param
            if _args_param is not None:
                _query_params.remove(_args_param)
            else:
                _args_param = ('args', {})
            _new_args = ('args', json.dumps([{
                'index': 0,
                'methodname': 'gradereport_user_get_grade_items',
                'args': _args_param[1]
            }]))
            _query_params.append(_new_args)
        # process the header parameters
        # process the form parameters
        if courseid is not None:
            _form_params += parse_form({'courseid': courseid})
        if groupid is not None:
            _form_params += parse_form({'groupid': groupid})
        if userid is not None:
            _form_params += parse_form({'userid': userid})
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'wstoken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path=_resource_path,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def login_token(
        self,
        password: StrictStr,
        service: StrictStr,
        username: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> LoginToken200Response:
        """login_token


        :param password: (required)
        :type password: str
        :param service: (required)
        :type service: str
        :param username: (required)
        :type username: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._login_token_serialize(
            password=password,
            service=service,
            username=username,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LoginToken200Response",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def login_token_with_http_info(
        self,
        password: StrictStr,
        service: StrictStr,
        username: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[LoginToken200Response]:
        """login_token


        :param password: (required)
        :type password: str
        :param service: (required)
        :type service: str
        :param username: (required)
        :type username: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._login_token_serialize(
            password=password,
            service=service,
            username=username,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LoginToken200Response",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def login_token_without_preload_content(
        self,
        password: StrictStr,
        service: StrictStr,
        username: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """login_token


        :param password: (required)
        :type password: str
        :param service: (required)
        :type service: str
        :param username: (required)
        :type username: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._login_token_serialize(
            password=password,
            service=service,
            username=username,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LoginToken200Response",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _login_token_serialize(
        self,
        password,
        service,
        username,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _resource_path = '/login/token.php'.split('#')[0]

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if '/webservice/rest/server.php' in _resource_path:
            _query_params.append(('moodlewsrestformat', 'json'))
            _query_params.append(('wsfunction', 'login_token'))
        if '/lib/ajax/service-nologin.php' in _resource_path:
            _args_param = None
            for _param in _query_params:
                if _param[0] == 'args':
                    _args_param = _param
            if _args_param is not None:
                _query_params.remove(_args_param)
            else:
                _args_param = ('args', {})
            _new_args = ('args', json.dumps([{
                'index': 0,
                'methodname': 'login_token',
                'args': _args_param[1]
            }]))
            _query_params.append(_new_args)
        # process the header parameters
        # process the form parameters
        if password is not None:
            _form_params += parse_form({'password': password})
        if service is not None:
            _form_params += parse_form({'service': service})
        if username is not None:
            _form_params += parse_form({'username': username})
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path=_resource_path,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def mod_assign_get_assignments(
        self,
        capabilities: Annotated[Optional[List[Optional[StrictStr]]], Field(description="list of capabilities used to filter courses")] = None,
        courseids: Annotated[Optional[List[Optional[StrictInt]]], Field(description="0 or more course ids")] = None,
        includenotenrolledcourses: Annotated[Optional[StrictBool], Field(description="whether to return courses that the user can see                                                                     even if is not enroled in. This requires the parameter courseids                                                                     to not be empty.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ModAssignGetAssignmentsResponse:
        """Returns the courses and assignments for the users capability

        Returns the courses and assignments for the users capability

        :param capabilities: list of capabilities used to filter courses
        :type capabilities: List[Optional[str]]
        :param courseids: 0 or more course ids
        :type courseids: List[Optional[int]]
        :param includenotenrolledcourses: whether to return courses that the user can see                                                                     even if is not enroled in. This requires the parameter courseids                                                                     to not be empty.
        :type includenotenrolledcourses: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._mod_assign_get_assignments_serialize(
            capabilities=capabilities,
            courseids=courseids,
            includenotenrolledcourses=includenotenrolledcourses,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModAssignGetAssignmentsResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def mod_assign_get_assignments_with_http_info(
        self,
        capabilities: Annotated[Optional[List[Optional[StrictStr]]], Field(description="list of capabilities used to filter courses")] = None,
        courseids: Annotated[Optional[List[Optional[StrictInt]]], Field(description="0 or more course ids")] = None,
        includenotenrolledcourses: Annotated[Optional[StrictBool], Field(description="whether to return courses that the user can see                                                                     even if is not enroled in. This requires the parameter courseids                                                                     to not be empty.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ModAssignGetAssignmentsResponse]:
        """Returns the courses and assignments for the users capability

        Returns the courses and assignments for the users capability

        :param capabilities: list of capabilities used to filter courses
        :type capabilities: List[Optional[str]]
        :param courseids: 0 or more course ids
        :type courseids: List[Optional[int]]
        :param includenotenrolledcourses: whether to return courses that the user can see                                                                     even if is not enroled in. This requires the parameter courseids                                                                     to not be empty.
        :type includenotenrolledcourses: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._mod_assign_get_assignments_serialize(
            capabilities=capabilities,
            courseids=courseids,
            includenotenrolledcourses=includenotenrolledcourses,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModAssignGetAssignmentsResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def mod_assign_get_assignments_without_preload_content(
        self,
        capabilities: Annotated[Optional[List[Optional[StrictStr]]], Field(description="list of capabilities used to filter courses")] = None,
        courseids: Annotated[Optional[List[Optional[StrictInt]]], Field(description="0 or more course ids")] = None,
        includenotenrolledcourses: Annotated[Optional[StrictBool], Field(description="whether to return courses that the user can see                                                                     even if is not enroled in. This requires the parameter courseids                                                                     to not be empty.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Returns the courses and assignments for the users capability

        Returns the courses and assignments for the users capability

        :param capabilities: list of capabilities used to filter courses
        :type capabilities: List[Optional[str]]
        :param courseids: 0 or more course ids
        :type courseids: List[Optional[int]]
        :param includenotenrolledcourses: whether to return courses that the user can see                                                                     even if is not enroled in. This requires the parameter courseids                                                                     to not be empty.
        :type includenotenrolledcourses: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._mod_assign_get_assignments_serialize(
            capabilities=capabilities,
            courseids=courseids,
            includenotenrolledcourses=includenotenrolledcourses,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModAssignGetAssignmentsResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _mod_assign_get_assignments_serialize(
        self,
        capabilities,
        courseids,
        includenotenrolledcourses,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'capabilities': 'csv',
            'courseids': 'csv',
        }

        _resource_path = '/webservice/rest/server.php#mod_assign_get_assignments'.split('#')[0]

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if '/webservice/rest/server.php' in _resource_path:
            _query_params.append(('moodlewsrestformat', 'json'))
            _query_params.append(('wsfunction', 'mod_assign_get_assignments'))
        if '/lib/ajax/service-nologin.php' in _resource_path:
            _args_param = None
            for _param in _query_params:
                if _param[0] == 'args':
                    _args_param = _param
            if _args_param is not None:
                _query_params.remove(_args_param)
            else:
                _args_param = ('args', {})
            _new_args = ('args', json.dumps([{
                'index': 0,
                'methodname': 'mod_assign_get_assignments',
                'args': _args_param[1]
            }]))
            _query_params.append(_new_args)
        # process the header parameters
        # process the form parameters
        if capabilities is not None:
            _form_params += parse_form({'capabilities': capabilities})
        if courseids is not None:
            _form_params += parse_form({'courseids': courseids})
        if includenotenrolledcourses is not None:
            _form_params += parse_form({'includenotenrolledcourses': includenotenrolledcourses})
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'wstoken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path=_resource_path,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def mod_assign_get_submissions(
        self,
        assignmentids: Annotated[List[Optional[StrictInt]], Field(description="1 or more assignment ids")],
        before: Annotated[Optional[StrictInt], Field(description="submitted before")] = None,
        since: Annotated[Optional[StrictInt], Field(description="submitted since")] = None,
        status: Annotated[Optional[StrictStr], Field(description="status")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ModAssignGetSubmissionsResponse:
        """Returns the submissions for assignments

        Returns the submissions for assignments

        :param assignmentids: 1 or more assignment ids (required)
        :type assignmentids: List[Optional[int]]
        :param before: submitted before
        :type before: int
        :param since: submitted since
        :type since: int
        :param status: status
        :type status: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._mod_assign_get_submissions_serialize(
            assignmentids=assignmentids,
            before=before,
            since=since,
            status=status,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModAssignGetSubmissionsResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def mod_assign_get_submissions_with_http_info(
        self,
        assignmentids: Annotated[List[Optional[StrictInt]], Field(description="1 or more assignment ids")],
        before: Annotated[Optional[StrictInt], Field(description="submitted before")] = None,
        since: Annotated[Optional[StrictInt], Field(description="submitted since")] = None,
        status: Annotated[Optional[StrictStr], Field(description="status")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ModAssignGetSubmissionsResponse]:
        """Returns the submissions for assignments

        Returns the submissions for assignments

        :param assignmentids: 1 or more assignment ids (required)
        :type assignmentids: List[Optional[int]]
        :param before: submitted before
        :type before: int
        :param since: submitted since
        :type since: int
        :param status: status
        :type status: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._mod_assign_get_submissions_serialize(
            assignmentids=assignmentids,
            before=before,
            since=since,
            status=status,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModAssignGetSubmissionsResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def mod_assign_get_submissions_without_preload_content(
        self,
        assignmentids: Annotated[List[Optional[StrictInt]], Field(description="1 or more assignment ids")],
        before: Annotated[Optional[StrictInt], Field(description="submitted before")] = None,
        since: Annotated[Optional[StrictInt], Field(description="submitted since")] = None,
        status: Annotated[Optional[StrictStr], Field(description="status")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Returns the submissions for assignments

        Returns the submissions for assignments

        :param assignmentids: 1 or more assignment ids (required)
        :type assignmentids: List[Optional[int]]
        :param before: submitted before
        :type before: int
        :param since: submitted since
        :type since: int
        :param status: status
        :type status: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._mod_assign_get_submissions_serialize(
            assignmentids=assignmentids,
            before=before,
            since=since,
            status=status,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModAssignGetSubmissionsResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _mod_assign_get_submissions_serialize(
        self,
        assignmentids,
        before,
        since,
        status,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'assignmentids': 'csv',
        }

        _resource_path = '/webservice/rest/server.php#mod_assign_get_submissions'.split('#')[0]

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if '/webservice/rest/server.php' in _resource_path:
            _query_params.append(('moodlewsrestformat', 'json'))
            _query_params.append(('wsfunction', 'mod_assign_get_submissions'))
        if '/lib/ajax/service-nologin.php' in _resource_path:
            _args_param = None
            for _param in _query_params:
                if _param[0] == 'args':
                    _args_param = _param
            if _args_param is not None:
                _query_params.remove(_args_param)
            else:
                _args_param = ('args', {})
            _new_args = ('args', json.dumps([{
                'index': 0,
                'methodname': 'mod_assign_get_submissions',
                'args': _args_param[1]
            }]))
            _query_params.append(_new_args)
        # process the header parameters
        # process the form parameters
        if assignmentids is not None:
            _form_params += parse_form({'assignmentids': assignmentids})
        if before is not None:
            _form_params += parse_form({'before': before})
        if since is not None:
            _form_params += parse_form({'since': since})
        if status is not None:
            _form_params += parse_form({'status': status})
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'wstoken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path=_resource_path,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def mod_assign_list_participants(
        self,
        assignid: Annotated[Optional[StrictInt], Field(description="assign instance id")],
        filter: Annotated[Optional[StrictStr], Field(description="search string to filter the results")],
        groupid: Annotated[Optional[StrictInt], Field(description="group id")],
        includeenrolments: Annotated[Optional[StrictBool], Field(description="Do return courses where the user is enrolled")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="maximum number of records to return")] = None,
        onlyids: Annotated[Optional[StrictBool], Field(description="Do not return all user fields")] = None,
        skip: Annotated[Optional[StrictInt], Field(description="number of records to skip")] = None,
        tablesort: Annotated[Optional[StrictBool], Field(description="Apply current user table sorting preferences.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ModAssignListParticipantsResponseInner]:
        """List the participants for a single assignment, with some summary info about their submissions.

        List the participants for a single assignment, with some summary info about their submissions.

        :param assignid: assign instance id (required)
        :type assignid: int
        :param filter: search string to filter the results (required)
        :type filter: str
        :param groupid: group id (required)
        :type groupid: int
        :param includeenrolments: Do return courses where the user is enrolled
        :type includeenrolments: bool
        :param limit: maximum number of records to return
        :type limit: int
        :param onlyids: Do not return all user fields
        :type onlyids: bool
        :param skip: number of records to skip
        :type skip: int
        :param tablesort: Apply current user table sorting preferences.
        :type tablesort: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._mod_assign_list_participants_serialize(
            assignid=assignid,
            filter=filter,
            groupid=groupid,
            includeenrolments=includeenrolments,
            limit=limit,
            onlyids=onlyids,
            skip=skip,
            tablesort=tablesort,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ModAssignListParticipantsResponseInner]",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def mod_assign_list_participants_with_http_info(
        self,
        assignid: Annotated[Optional[StrictInt], Field(description="assign instance id")],
        filter: Annotated[Optional[StrictStr], Field(description="search string to filter the results")],
        groupid: Annotated[Optional[StrictInt], Field(description="group id")],
        includeenrolments: Annotated[Optional[StrictBool], Field(description="Do return courses where the user is enrolled")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="maximum number of records to return")] = None,
        onlyids: Annotated[Optional[StrictBool], Field(description="Do not return all user fields")] = None,
        skip: Annotated[Optional[StrictInt], Field(description="number of records to skip")] = None,
        tablesort: Annotated[Optional[StrictBool], Field(description="Apply current user table sorting preferences.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ModAssignListParticipantsResponseInner]]:
        """List the participants for a single assignment, with some summary info about their submissions.

        List the participants for a single assignment, with some summary info about their submissions.

        :param assignid: assign instance id (required)
        :type assignid: int
        :param filter: search string to filter the results (required)
        :type filter: str
        :param groupid: group id (required)
        :type groupid: int
        :param includeenrolments: Do return courses where the user is enrolled
        :type includeenrolments: bool
        :param limit: maximum number of records to return
        :type limit: int
        :param onlyids: Do not return all user fields
        :type onlyids: bool
        :param skip: number of records to skip
        :type skip: int
        :param tablesort: Apply current user table sorting preferences.
        :type tablesort: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._mod_assign_list_participants_serialize(
            assignid=assignid,
            filter=filter,
            groupid=groupid,
            includeenrolments=includeenrolments,
            limit=limit,
            onlyids=onlyids,
            skip=skip,
            tablesort=tablesort,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ModAssignListParticipantsResponseInner]",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def mod_assign_list_participants_without_preload_content(
        self,
        assignid: Annotated[Optional[StrictInt], Field(description="assign instance id")],
        filter: Annotated[Optional[StrictStr], Field(description="search string to filter the results")],
        groupid: Annotated[Optional[StrictInt], Field(description="group id")],
        includeenrolments: Annotated[Optional[StrictBool], Field(description="Do return courses where the user is enrolled")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="maximum number of records to return")] = None,
        onlyids: Annotated[Optional[StrictBool], Field(description="Do not return all user fields")] = None,
        skip: Annotated[Optional[StrictInt], Field(description="number of records to skip")] = None,
        tablesort: Annotated[Optional[StrictBool], Field(description="Apply current user table sorting preferences.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List the participants for a single assignment, with some summary info about their submissions.

        List the participants for a single assignment, with some summary info about their submissions.

        :param assignid: assign instance id (required)
        :type assignid: int
        :param filter: search string to filter the results (required)
        :type filter: str
        :param groupid: group id (required)
        :type groupid: int
        :param includeenrolments: Do return courses where the user is enrolled
        :type includeenrolments: bool
        :param limit: maximum number of records to return
        :type limit: int
        :param onlyids: Do not return all user fields
        :type onlyids: bool
        :param skip: number of records to skip
        :type skip: int
        :param tablesort: Apply current user table sorting preferences.
        :type tablesort: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._mod_assign_list_participants_serialize(
            assignid=assignid,
            filter=filter,
            groupid=groupid,
            includeenrolments=includeenrolments,
            limit=limit,
            onlyids=onlyids,
            skip=skip,
            tablesort=tablesort,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ModAssignListParticipantsResponseInner]",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _mod_assign_list_participants_serialize(
        self,
        assignid,
        filter,
        groupid,
        includeenrolments,
        limit,
        onlyids,
        skip,
        tablesort,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _resource_path = '/webservice/rest/server.php#mod_assign_list_participants'.split('#')[0]

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if '/webservice/rest/server.php' in _resource_path:
            _query_params.append(('moodlewsrestformat', 'json'))
            _query_params.append(('wsfunction', 'mod_assign_list_participants'))
        if '/lib/ajax/service-nologin.php' in _resource_path:
            _args_param = None
            for _param in _query_params:
                if _param[0] == 'args':
                    _args_param = _param
            if _args_param is not None:
                _query_params.remove(_args_param)
            else:
                _args_param = ('args', {})
            _new_args = ('args', json.dumps([{
                'index': 0,
                'methodname': 'mod_assign_list_participants',
                'args': _args_param[1]
            }]))
            _query_params.append(_new_args)
        # process the header parameters
        # process the form parameters
        if assignid is not None:
            _form_params += parse_form({'assignid': assignid})
        if filter is not None:
            _form_params += parse_form({'filter': filter})
        if groupid is not None:
            _form_params += parse_form({'groupid': groupid})
        if includeenrolments is not None:
            _form_params += parse_form({'includeenrolments': includeenrolments})
        if limit is not None:
            _form_params += parse_form({'limit': limit})
        if onlyids is not None:
            _form_params += parse_form({'onlyids': onlyids})
        if skip is not None:
            _form_params += parse_form({'skip': skip})
        if tablesort is not None:
            _form_params += parse_form({'tablesort': tablesort})
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'wstoken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path=_resource_path,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


