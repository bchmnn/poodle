package internal

import (
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"

	"bchmnn/poodle-cli/internal/util"
)

var ExportWebservicesScript = `<?php

/**
 * CLI script to export web service JSON
 *
 * @package   moodle-api-gen
 * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 * @author    Joshua Pare
 *
 * This script is part of a custom package for autogenerated Moodle clients and
 * documentation.
 *
 * Repository: https://github.com/joshuapare/moodle-api-gen
 */

define('CLI_SCRIPT', true);

use core_external\external_api;

require(__DIR__.'/../../config.php');
require_once($CFG->libdir.'/clilib.php');
require_once($CFG->dirroot.'/webservice/lib.php');
require_once($CFG->libdir.'/adminlib.php');

list($options, $unrecognized) = cli_get_params(
    [
        'file' => false,
        'help' => false
    ],
    [
        'f' => 'file',
        'h' => 'help'
    ]
);

if ($unrecognized) {
    cli_error(get_string('cliunknowoption', 'admin', implode("\n  ", $unrecognized)));
}

if ($options['help']) {
    $help = "Export web service JSON.

Options:
-f, --file     Optional: Output to a specified file instead of stdout.
-h, --help     Print out this help.

Example:
\$sudo -u www-data /usr/bin/php admin/cli/export_webservices.php --file=output.json

";
    echo $help;
    exit(0);
}

// get all the function descriptions programatically
$functions = $DB->get_records('external_functions', [], 'name');
$functiondescs = [];
foreach ($functions as $function) {
    try {
        $functiondescs[$function->name] = external_api::external_function_info($function);
    } catch (Throwable $exception) {
        cli_error($exception->getMessage());
    }
}

$formatted = json_encode($functiondescs, JSON_PRETTY_PRINT);

if ($options['file']) {
    file_put_contents($options['file'], $formatted);
    cli_writeln("Output written to {$options['file']}");
} else {
    echo $formatted . PHP_EOL;
}

exit(0);
`

type Extractor struct {
	Moodle           *util.Moodle
	MoodleDockerPath string
	OutPath          string
	ToStdout         bool
	LogWriter        io.Writer
	Log              *log.Logger
}

func NewExtractor(moodle *util.Moodle, moodleDockerPath string, outPath string, toStdout bool) *Extractor {
	var logWriter io.Writer
	if toStdout {
		logWriter = os.Stderr
	} else {
		logWriter = os.Stdout
	}

	return &Extractor{
		Moodle:           moodle,
		MoodleDockerPath: moodleDockerPath,
		OutPath:          outPath,
		ToStdout:         toStdout,
		LogWriter:        logWriter,
		Log:              log.New(logWriter, "[EXTRACTOR] ", log.LstdFlags),
	}
}

func (e *Extractor) Extract() error {
	useMoodleDocker := e.MoodleDockerPath != ""
	var cleanup func()
	var err error
	if useMoodleDocker {
		cleanup, err = e.SetupMoodleDocker()
	} else {
		cleanup, err = e.SetupMoodle()
	}
	defer cleanup()
	if err != nil {
		return err
	}
	return e.RunExportWebservices()
}

func (e *Extractor) ComposeBin() string {
	return filepath.Join(e.MoodleDockerPath, "bin", "moodle-docker-compose")
}

func (e *Extractor) WaitForDbBin() string {
	return filepath.Join(e.MoodleDockerPath, "bin", "moodle-docker-wait-for-db")
}

func (e *Extractor) ExportScriptPath() string {
	return filepath.Join(e.Moodle.Path, "admin", "cli", "export_webservices.php")
}

func (e *Extractor) GetEnv() []util.EnvItem {
	return []util.EnvItem{
		{
			Key:   "MOODLE_DOCKER_WWWROOT",
			Value: e.Moodle.Path,
		},
		{
			Key:   "MOODLE_DOCKER_DB",
			Value: "pgsql",
		},
	}
}

func (e *Extractor) RunCompose(arg ...string) error {
	compose := e.ComposeBin()

	process := util.Process{
		Name: compose,
		Arg:  arg,
		Env:  e.GetEnv(),
		Stdout: &util.ProcessWriter{
			Prefix: "[MOODLE-DOCKER-COMPOSE] ",
			Writer: e.LogWriter,
		},
		Stderr: &util.ProcessWriter{
			Prefix: "[MOODLE-DOCKER-COMPOSE] ",
			Writer: os.Stderr,
		},
	}

	e.Log.Println("Running:", process.String())

	return process.Run()
}

func (e *Extractor) RunWaitForDb() error {
	waitForDb := e.WaitForDbBin()

	process := util.Process{
		Name: waitForDb,
		Env:  e.GetEnv(),
		Stdout: &util.ProcessWriter{
			Prefix: "[WAIT-FOR-DB] ",
			Writer: e.LogWriter,
		},
		Stderr: &util.ProcessWriter{
			Prefix: "[WAIT-FOR-DB] ",
			Writer: os.Stderr,
		},
	}

	e.Log.Println("Running:", process.String())

	return process.Run()
}

func (e *Extractor) SetupMoodle() (func(), error) {
	dst := filepath.Join(e.Moodle.Path, "admin", "cli", "export_webservices.php")
	e.Log.Printf("Writing %s\n", dst)
	os.WriteFile(dst, []byte(ExportWebservicesScript), 0644)
	cleanup := func() {
		e.Log.Println("Removing", dst)
		os.Remove(dst)
	}
	return cleanup, nil
}

func (e *Extractor) SetupMoodleDocker() (func(), error) {
	tempDir, err := os.MkdirTemp("", "poodle-*")
	if err != nil {
		return util.Noop, err
	}
	e.Log.Println("Working directory:", tempDir)
	cleanup := func() {
		e.Log.Println("Removing", tempDir)
		os.RemoveAll(tempDir)
	}

	src := e.Moodle.Path
	dst := tempDir
	e.Log.Printf("Copying %s to %s\n", src, dst)
	util.Copy(src, dst)
	moodle, _ := util.NewMoodle(tempDir)
	e.Moodle = moodle

	dst = e.ExportScriptPath()
	e.Log.Printf("Writing %s\n", dst)
	os.WriteFile(dst, []byte(ExportWebservicesScript), 0644)

	src = filepath.Join(e.MoodleDockerPath, "config.docker-template.php")
	dst = filepath.Join(e.Moodle.Path, "config.php")
	e.Log.Printf("Copying %s to %s\n", src, dst)
	util.Copy(src, dst)

	err = e.RunCompose("up", "-d")
	if err != nil {
		return cleanup, err
	}

	cleanup = func() {
		e.RunCompose("down")
		e.Log.Println("Removing", tempDir)
		os.RemoveAll(tempDir)
	}

	err = e.RunWaitForDb()
	if err != nil {
		return cleanup, err
	}

	err = e.RunCompose(
		"exec",
		"webserver",
		"php",
		"admin/cli/install_database.php",
		"--agree-license",
		"--adminpass=admin",
	)

	if err != nil {
		return cleanup, err
	}

	return cleanup, nil
}

func (e *Extractor) RunExportWebservices() error {
	useMoodleDocker := e.MoodleDockerPath != ""
	writer := os.Stdout
	var err error
	if !e.ToStdout {
		writer, err = os.Create(e.OutPath)
		if err != nil {
			return fmt.Errorf("Could not create file %s", e.OutPath)
		}
		defer writer.Close()
	}

	process := util.Process{
		Stdout: &util.ProcessWriter{
			Writer: writer,
		},
	}

	if useMoodleDocker {
		process.Stderr = &util.ProcessWriter{
			Prefix: "[MOODLE-DOCKER-COMPOSE] ",
			Writer: os.Stderr,
		}
		process.Name = e.ComposeBin()
		process.Arg = []string{
			"exec",
			"webserver",
			"php",
			"admin/cli/export_webservices.php",
		}
		process.Env = e.GetEnv()
	} else {
		process.Stderr = &util.ProcessWriter{
			Prefix: "[PHP] ",
			Writer: os.Stderr,
		}
		process.Name = "php"
		process.Arg = []string{
			e.ExportScriptPath(),
		}
	}

	e.Log.Println("Running:", process.String())

	err = process.Run()
	if err != nil {
		return err
	}

	if !e.ToStdout {
		e.Log.Println("Results written to", e.OutPath)
	}
	return nil
}
